# 분할 정복 알고리즘

> ### **합병 정렬**

![](C:\Users\민됴이\Desktop\mergesort.png)

##### 1. 원소를 한개씩 분할해준다.

##### 2. 2개씩 합치는데 정렬이 되게끔 합친다.



> ### 합병정렬의 시간복잡도

분할을 할 때 매번 절반씩 나누므로 **O(NlogN)**만큼의 시간복잡도를 가진다.



> ### **퀵 정렬**

![](C:\Users\민됴이\Desktop\quicksort.webp)

##### 1. 기준이 될 pivot원소를 한개 고른다.

##### 2. pivot원소를 기준으로 작은건 왼쪽 큰건 오른쪽으로 몰아넣는다.

##### 3. pivot기준 왼쪽(pivot보다 작은 쪽)리스트와 오른쪽(pivot보다 큰 쪽)리스트의 각 pivot을 정해 과정을 반복한다.



> ### 퀵 정렬의 **시간복잡도**

퀵 정렬같은 경우 최선의 경우와 최악의 경우의 시간복잡도가 다른데

최선의 경우일 땐 **O(NlogN)**

최악의 경우일 땐 **O(N^2)**의 시간복잡도를 가지게 된다.

리스트가 계속 불균형하게 나누어지는 경우나 이미 정렬된 리스트에 대하여 퀵정렬을 실행할 때가 최악의 경우라고 볼 수 있다.



> ### **분할 정복 알고리즘 문제 예시**

![](C:\Users\민됴이\Desktop\z.png)

일단 문제 풀이의 힌트는

**"****N > 1인 경우, 배열을 크기가 2****N-1** **× 2****N-1****로 4등분 한 후에 재귀적으로 순서대로 방문한다."**

이 문장에서 얻었다. 아 재귀적 = 재귀함수 써야겠구나 해서 재귀적으로 접근을 했다.

일단 처음엔 r과 c를 가지고 숫자를 만들 수 있는 규칙을 생각해보려했지만 아닌 것 같아 포기하고

판을 자세히 보니 4등분을 할 수 있겠다라는 생각을 했다.(어짜피 각 변이 2^N이니까)

그렇게 r과c가 속한 사분면을 찾고 그 사분면을 자르고 다시 r과 c가 속한 사분면을 찾고 또 그 사분면을 자르고 이 과정을 반복하면 되겠다라는 생각이 들었다. 마지막으로 한변의 길이가 2가되었을 때 재귀함수를 탈출하게끔 코드를 작성했다.

```
def ss(n, r, c, start, end):

       nn = n//2  #한변의 길이를 2로나눈 수

       if nn == 1:

              return start+(r*2)+c   #만약 한변의 길이가 2가 되었을 때 재귀함수 탈출

       if r < nn and c < nn:

              return ss(nn, r, c, start, nn**2-1+end)        #2사분면에 존재할 때

       if r < nn and c >= nn:

              return ss(nn, r, c-nn, nn**2+start, 2*(nn**2)-1+end)    #1사분면에 존재할 때

       if r >= nn and c < nn:

              return ss(nn, r-nn, c, 2*(nn**2)+start, 3*(nn**2)-1+end)  #3사분면에 존재할 때

       if r >= nn and c >= nn:

              return ss(nn, r-nn, c-nn, 3*(nn**2)+start, 4*(nn**2)-1+end #4사분면에 존재할때


N, r, c = map(int, input().split())
print(ss(2**N, r, c, 0, 2**(2*N)-1))
```

